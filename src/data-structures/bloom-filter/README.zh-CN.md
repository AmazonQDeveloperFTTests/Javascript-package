# 布隆过滤器

布隆过滤器是一种空间高效的概率数据结构，旨在测试元素是否存在于集合中。它被设计得非常快，并且以潜在的误报为代价使用最少的内存。误报是可能的，漏报是不可能的。换句话说，某元素的查询结果只可能有两种：“可能在集合中”或者“绝对不在集合中”。

Bloom提出的这项技术适用于这样的场景：使用“传统的”无错误散列技术将导致源数据占用过量内存。

## 算法描述

空的布隆过滤器是由m位组成的位数组，全部设置为0。还必须定义k个不同的散列函数，每个散列函数将一些集合元素映射或散列到m个阵列位置之一，从而产生均匀的随机分布。通常，k是一个常数，远小于m，它与要添加的元素的数量成正比；k的精确选择和m的比例常数由过滤器的预期误报率确定。

下面是布隆过滤器的一个示例，表示集合{x，y，z}。彩色箭头显示每个集合元素映射到的位数组中的位置。从元素w散列到位数组位置可以看出，该元素不在集合{x，y，z}中。对于下图来说，m=18，k=3。

![Bloom Filter](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg)

## 操作

布隆过滤器可以执行两个主要操作：插入和搜索。搜索可能会导致误报，且无法删除布隆过滤器中的元素。

换句话说，过滤器可以添加新元素。当我们检查某个元素之前是否已插入时，它可以告诉我们：“否”或“可能”。

此外，插入和搜索的时间复杂度均为O(1)。

## 初始化过滤器

布隆过滤器是通过分配特定大小来创建的。在我们的示例中，我们使用`100`作为默认长度。所有位置被初始化为`false`。

### 插入

在插入期间，使用多个散列函数(在本例中为3个)来创建输入的哈希值。对于生成的每个哈希值，我们只需将Bloom过滤器中的值更改为`true`。

### 搜索

在搜索期间，将调用相同的散列函数，并用于对输入进行散列。然后我们检查是否。 INDEX  RECEIVED_ALL_在内部的值为`true`。我们的布隆过滤器。如果它们_all_的值为。 “真的”，我们知道布隆过滤器可能有。先前插入的值。

也就是说过滤器中不一定有该值，因为以前插入的其他值可能将过滤器中相应的位反转为true。因此，除非之前只插入了单个元素，否则不可能绝对确定查找的元素一定存在于过滤器中。

在检查布隆过滤器的哈希函数返回的索引时，如果其中一个索引的值为`false`，我们可以确定该元素以前没有插入过。

## 误报率

误报的概率由三个因素决定：布隆过滤器的大小，使用的散列函数的数量以及已插入过滤器的元素数量。



计算误报概率的公式是：

( 1 - e <sup>-kn/m</sup> ) <sup>k</sup>

`k` = 散列函数数量

`m` = 布隆过滤器大小

`n` = 插入元素数量

k, m和n应该根据误报率的可接受程度来选择。如果选择了这些值，而结果的概率过高，则应该调整这些值并重新计算概率。

## 应用

bloom过滤器可以在博客网站上使用。如果目标是只向读者展示他们以前从未见过的文章，那么bloom过滤器是完美的。它可以根据文章存储散列值。用户阅读了几篇文章后，可以将它们插入到过滤器中。下次用户访问该站点时，这些文章就可以从结果中过滤出来。

有些文章难免会被错误地过滤掉，但成本是可以接受的，即有几篇文章用户从来没有看到过，但他们每次访问该网站都会看到之前没有阅读过的文章，

## 参考

- [Wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)
- [Bloom Filters by Example](http://llimllib.github.io/bloomfilter-tutorial/)
- [Calculating False Positive Probability](https://hur.st/bloomfilter/?n=4&p=&m=18&k=3)
- [Bloom Filters on Medium](https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff)
- [Bloom Filters on YouTube](https://www.youtube.com/watch?v=bEmBh1HtYrw)